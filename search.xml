<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[工作中遇到的坑]]></title>
    <url>%2F2019%2F08%2F02%2F%E5%B7%A5%E4%BD%9C%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[IOS H5页面播放视频问题前端处理文件sha256值]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>H5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React useState]]></title>
    <url>%2F2019%2F07%2F14%2FuseState%2F</url>
    <content type="text"><![CDATA[useState 基础用法1234567891011function App() &#123; const [n, setN] = React.useState(0); return ( &lt;div className="app"&gt; &lt;p&gt;&#123;n&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setN(n + 1)&#125;&gt;n+1&lt;/button&gt; &lt;/div&gt; );&#125;ReactDOM.render(&lt;App /&gt;, rootElement); 首次渲染：render &lt;App /&gt;，调用 App 函数，得到虚拟 div（一个对象），创建真实 div； 当点击 button 时，会调用 setN 函数，再次 render &lt;App /&gt;； 再次调用 App 函数，得到虚拟 div，DOM diff 更新真实 div；每次运行 App 函数，都会运行useState(0)，由此看似运行useState(0)，变量 n 又是 0，但其实不然，第二次调用时 n 变为了 1。 原理分析 setN一定会修改某个数据 x，把n+1的值存入 x； setN一定会出发App()，重新渲染； useState肯定会从数据 x 里读取 n 的最新值； 那每个组件应该会有自己的一个数据 x，暂时将其命名为stateuseState原理类似如下代码： 1234567891011121314151617181920212223242526let _state;function myUseState(initialValue) &#123; _state = _state || initialValue; function setState(newState) &#123; _state = newState; render(); &#125; return [_state, setState];&#125;const render = () =&gt; ReactDOM.render(&lt;App /&gt;, rootElement);function App() &#123; const [n, setN] = myUseState(0); return ( &lt;div className="App"&gt; &lt;p&gt;&#123;n&#125;&lt;/p&gt; &lt;p&gt; &lt;button onClick=&#123;() =&gt; setN(n + 1)&#125;&gt;+1&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; );&#125;ReactDOM.render(&lt;App /&gt;, rootElement); 这样的原理，其实还是有问题的，因为如果 App 函数内不止一次调用了useState函数，那这个 state 就会冲突。 进一步源码改进1234567891011121314151617181920212223242526272829303132333435363738let _state = [];let index = 0;function myUseState(initialValue) &#123; const currentIndex = index; index += 1; _state[currentIndex] = _state[currentIndex] || initialValue; const setState = newState =&gt; &#123; _state[currentIndex] = newState; render(); &#125;; return [_state[currentIndex], setState];&#125;const render = () =&gt; &#123; index = 0; ReactDOM.render(&lt;App /&gt;, rootElement);&#125;;function App() &#123; const [n, setN] = myUseState(0); const [m, setM] = myUseState(0); console.log(_state); return ( &lt;div className="App"&gt; &lt;p&gt;&#123;n&#125;&lt;/p&gt; &lt;p&gt; &lt;button onClick=&#123;() =&gt; setN(n + 1)&#125;&gt;+1&lt;/button&gt; &lt;/p&gt; &lt;p&gt;&#123;m&#125;&lt;/p&gt; &lt;p&gt; &lt;button onClick=&#123;() =&gt; setM(m + 1)&#125;&gt;+1&lt;/button&gt; &lt;/p&gt; &lt;/div&gt; );&#125;ReactDOM.render(&lt;App /&gt;, rootElement); 用次方案会有一个缺陷，就是调用useState一定要注意顺序，所以再调用时，一定不能放在if里边。而实际调用useState时如果放在了if内，React 会报错。 总结 每个函数组件对应一个React节点 每个节点保存着state和index useState会读取state[index] index由useState出现的顺序决定 setState会修改state，并处罚更新]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React Hooks]]></title>
    <url>%2F2019%2F07%2F14%2FHooks%2F</url>
    <content type="text"><![CDATA[useState使用状态12const [n, setN] = React.useStaet(0);const [user, setUser] = React.useState(&#123; name: "F" &#125;); 注意事项：不可局部更新，地址要变 123456789101112131415function App() &#123; const [user, setUser] = useState(&#123; name: "Frank", age: 18 &#125;); const onClick = () =&gt; &#123; setUser(&#123; name: "Jack" &#125;); &#125;; return ( &lt;div className="App"&gt; &lt;h1&gt;&#123;user.name&#125;&lt;/h1&gt; &lt;h2&gt;&#123;user.age&#125;&lt;/h2&gt; &lt;button onClick=&#123;onClick&#125;&gt;Click&lt;/button&gt; &lt;/div&gt; );&#125; 如果是这样更新user对象，实际并未更新，需要重新一个对象传给setUser函数，实际上，setState(obj)如果obj地址不变，那么 React 就认为数据没有变化。通常以setUser({...user, name: &#39;Jack&#39;})的方式来更新。因为setState不会帮我们合并属性，其实useReducer也不会合并属性。 useState 接受函数123const [state, setState] = useState(() =&gt; &#123; return initialState;&#125;); 该函数返回初始state，并且只执行一次 setState 接受函数12345678910111213141516function App() &#123; const [n, setN] = useState(0); const onClick = () =&gt; &#123; setN(n + 1); setN(n + 1); // 你会发现 n 不能加 2 // setN(i=&gt;i+1) // setN(i=&gt;i+1) &#125;; return ( &lt;div className="App"&gt; &lt;h1&gt;n: &#123;n&#125;&lt;/h1&gt; &lt;button onClick=&#123;onClick&#125;&gt;+2&lt;/button&gt; &lt;/div&gt; );&#125; 在这种时候，需要不止一次调用的时候，就需要传函数来实现，如果能接受这种形式，应该优先使用这种式。 useReducer使用 useReducer，用来践行 Flux/Redux 的思想1234567891011121314151617181920212223242526272829303132const initial = &#123; n: 0&#125;;const reducer = (state, action) =&gt; &#123; if (action.type === "add") &#123; return &#123; n: state.n + action.number &#125;; &#125; else if (action.type === "multi") &#123; return &#123; n: state.n * 2 &#125;; &#125; else &#123; throw new Error("unknown type"); &#125;&#125;;function App() &#123; const [state, dispatch] = useReducer(reducer, initial); const &#123; n &#125; = state; const onClick = () =&gt; &#123; dispatch(&#123; type: "add", number: 1 &#125;); &#125;; const onClick2 = () =&gt; &#123; dispatch(&#123; type: "add", number: 2 &#125;); &#125;; return ( &lt;div className="App"&gt; &lt;h1&gt;n: &#123;n&#125;&lt;/h1&gt; &lt;button onClick=&#123;onClick&#125;&gt;+1&lt;/button&gt; &lt;button onClick=&#123;onClick2&#125;&gt;+2&lt;/button&gt; &lt;/div&gt; );&#125; 创建初始值initialState； 创建所有操作reducer(state, action)； 传给useReducer，得到读和写 API； 调用 =&gt; ({ type: &#39;操作类型&#39; })总的来说，useReducer是useState的复杂版 如何代替 Redux123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129const store = &#123; user: null, books: null, movies: null&#125;;function reducer(state, action) &#123; switch (action.type) &#123; case "setUser": return &#123; ...state, user: action.user &#125;; case "setBooks": return &#123; ...state, books: action.books &#125;; case "setMovies": return &#123; ...state, movies: action.movies &#125;; default: throw new Error(); &#125;&#125;const Context = React.createContext(null);function App() &#123; const [state, dispatch] = useReducer(reducer, store); const api = &#123; state, dispatch &#125;; return ( &lt;Context.Provider value=&#123;api&#125;&gt; &lt;User /&gt; &lt;hr /&gt; &lt;Books /&gt; &lt;Movies /&gt; &lt;/Context.Provider&gt; );&#125;function User() &#123; const &#123; state, dispatch &#125; = useContext(Context); useEffect(() =&gt; &#123; ajax("/user").then(user =&gt; &#123; dispatch(&#123; type: "setUser", user: user &#125;); &#125;); &#125;, []); return ( &lt;div&gt; &lt;h1&gt;个人信息&lt;/h1&gt; &lt;div&gt;name: &#123;state.user ? state.user.name : ""&#125;&lt;/div&gt; &lt;/div&gt; );&#125;function Books() &#123; const &#123; state, dispatch &#125; = useContext(Context); useEffect(() =&gt; &#123; ajax("/books").then(books =&gt; &#123; dispatch(&#123; type: "setBooks", books: books &#125;); &#125;); &#125;, []); return ( &lt;div&gt; &lt;h1&gt;我的书籍&lt;/h1&gt; &lt;ol&gt; &#123;state.books ? state.books.map(book =&gt; &lt;li key=&#123;book.id&#125;&gt;&#123;book.name&#125;&lt;/li&gt;) : "加载中"&#125; &lt;/ol&gt; &lt;/div&gt; );&#125;function Movies() &#123; const &#123; state, dispatch &#125; = useContext(Context); useEffect(() =&gt; &#123; ajax("/movies").then(movies =&gt; &#123; dispatch(&#123; type: "setMovies", movies: movies &#125;); &#125;); &#125;, []); return ( &lt;div&gt; &lt;h1&gt;我的电影&lt;/h1&gt; &lt;ol&gt; &#123;state.movies ? state.movies.map(movie =&gt; &lt;li key=&#123;movie.id&#125;&gt;&#123;movie.name&#125;&lt;/li&gt;) : "加载中"&#125; &lt;/ol&gt; &lt;/div&gt; );&#125;const rootElement = document.getElementById("root");ReactDOM.render(&lt;App /&gt;, rootElement);// 帮助函数// 假 ajax// 两秒钟后，根据 path 返回一个对象，必定成功不会失败function ajax(path) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; if (path === "/user") &#123; resolve(&#123; id: 1, name: "Frank" &#125;); &#125; else if (path === "/books") &#123; resolve([ &#123; id: 1, name: "JavaScript 高级程序设计" &#125;, &#123; id: 2, name: "JavaScript 精粹" &#125; ]); &#125; else if (path === "/movies") &#123; resolve([ &#123; id: 1, name: "爱在黎明破晓前" &#125;, &#123; id: 2, name: "恋恋笔记本" &#125; ]); &#125; &#125;, 2000); &#125;);&#125; 将数据集中在一个store对象中； 将所有操作集中在reducer； 创建一个Context； 创建对数据的读写 API； 将第四步的内容放到第三步的Context； 用Context.Provider将Context提供给所有组件； 各个组件用useContext获取读写 API； useContext上下文全局变量是全局的上下文，上下文是局部的全局变量。 使用方法1234567891011121314151617181920212223242526272829303132333435const C = createContext(null);function App() &#123; console.log("App 执行了"); const [n, setN] = useState(0); return ( &lt;C.Provider value=&#123;&#123; n, setN &#125;&#125;&gt; &lt;div className="App"&gt; &lt;Baba /&gt; &lt;/div&gt; &lt;/C.Provider&gt; );&#125;function Baba() &#123; const &#123; n, setN &#125; = useContext(C); return ( &lt;div&gt; 我是爸爸 n: &#123;n&#125; &lt;Child /&gt; &lt;/div&gt; );&#125;function Child() &#123; const &#123; n, setN &#125; = useContext(C); const onClick = () =&gt; &#123; setN(i =&gt; i + 1); &#125;; return ( &lt;div&gt; 我是儿子 我得到的 n: &#123;n&#125; &lt;button onClick=&#123;onClick&#125;&gt;+1&lt;/button&gt; &lt;/div&gt; );&#125; 使用C = createContext(initial)创建上下文； 使用&lt;C.provider&gt;圈定作用域； 在作用域内使用useContext(C)来使用上下文； 注意事项不是响应式，在一个模块降C里面的值改变，另一个模块不会感知到这个变化。 useEffect副作用对环境的改变纪委副作用，如修改 document.title，但不一定非要吧副作用放在useEffect里，实际上叫做afterRender更好，每次 render 后运行。 用途 作为componentDidMount使用，[]作第二个参数； 作为componentDidUpdate使用，可指定依赖； 作为componentWillUnmount使用，用过 return；以上三种用途可以同时存在 特点如果同时存在多个useEffect，会按照出现次序执行。 useLayoutEffect布局副作用useEffect在浏览器渲染完成后执行，useLayoutEffect在浏览器渲染前执行。 特点 useLayoutEffect总是比useEffect先执行 useLayoutEffect里的任务最好影响了 Layout 经验为了用户体验，useLayoutEffect其实会增加 DOM 的渲染时间，优先使用useEffect。 useMemo如何理解 useMemo首先要理解useMemo，必须要先将React.memo，示例代码如下： 12345678910111213141516171819202122232425function App() &#123; const [n, setN] = React.useState(0); const [m, setM] = React.useState(0); const onClick = () =&gt; &#123; setN(n + 1); &#125;; return ( &lt;div className="App"&gt; &lt;div&gt; &lt;button onClick=&#123;onClick&#125;&gt;update n &#123;n&#125;&lt;/button&gt; &lt;/div&gt; &#123;/* &lt;Child data=&#123;m&#125; /&gt; */&#125; &lt;Child2 data=&#123;m&#125; /&gt; &lt;/div&gt; );&#125;function Child(props) &#123; // 假设这里有大量代码 console.log("child 执行了"); return &lt;div&gt;child: &#123;props.data&#125;&lt;/div&gt;;&#125;const Child2 = React.memo(Child); 这样使用了React.memo的Child2组件，在n变化时，Child2组件并不会重新render。 但是，React.memo还是有一个问题，改造上述代码如下： 1234567891011121314function App() &#123; // ... const onClickChild = () =&gt; &#123; console.log(m); &#125;; retrun( &lt;div className="App"&gt; &lt;Child2 data=&#123;m&#125; onClick=&#123;onClickChild&#125; /&gt; &lt;/div&gt; );&#125;// ... 这样的话，即使Child2组件使用了React.memo，Child2组件还是会重新render，原因其实就是onClickChild被赋值了一个新的函数，新旧函数功能一样，但是地址是不一样的。那如何解决这样的问题呢？所以出现了useMemo，修改代码如下： 123456789101112131415161718function App() &#123; // ... const onClickChild = useMemo(() =&gt; &#123; const fn = div =&gt; &#123; console.log("on click child, m: " + m); console.log(div); &#125;; return fn; &#125;, [m]); retrun( &lt;div className="App"&gt; &lt;Child2 data=&#123;m&#125; onClick=&#123;onClickChild&#125; /&gt; &lt;/div&gt; );&#125;// ... useMemo 特点 第一个参数是一个函数：() =&gt; value； 第二个参数是依赖[m,n]； 只有当依赖变化是，才会计算出新的value； 如果依赖不变，那么就重用之前的value； useMemo 注意点如果上述value是一个函数，那可能就会写成这样：useMemo(() =&gt; (x) =&gt; console.log(x))，这是一个返回函数的函数。那会不会觉得很难用呢？于是出现了useCallback。 useCallback修改上述代码，使用useCallback来代替useMemo。 1234567891011// const onClickChild = useMemo(() =&gt; &#123;// const fn = div =&gt; &#123;// console.log("on click child, m: " + m);// console.log(div);// &#125;;// return fn;// &#125;, [m]);const onClickChild = useMemo(() =&gt; &#123; console.log("on click child, m: " + m);&#125;, [m]); useCallback(x =&gt; log(x), [m])等价于 useMemo(() =&gt; x =&gt; log(x), [m])。 useRef目的如果需要一个值，在组件不断 render 时保持不变，初始化：const count = useRef(0)，读取：count.current。为什么需要这样读取呢？原因是为了保证两次使用useRef是同一个值（引用了一个对象地址，地址不会变）。useRef不能自动是的组件自动 render，因为这不符合 React 的理念，如果想有这个功能，就必须自己加功能，要监听 ref，当ref.current变化是，调用setN即可。 forwardRefuseImperativeHandle自定义 Hook1234567891011121314151617181920212223242526const useList = () =&gt; &#123; const [list, setList] = useState(null); useEffect(() =&gt; &#123; ajax("/list").then(list =&gt; &#123; setList(list); &#125;); &#125;, []); // [] 确保只在第一次运行 return &#123; list: list, setList: setList &#125;;&#125;;export default useList;function ajax() &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve([ &#123; id: 1, name: "Frank" &#125;, &#123; id: 2, name: "Jack" &#125;, &#123; id: 3, name: "Alice" &#125;, &#123; id: 4, name: "Bob" &#125; ]); &#125;, 2000); &#125;);&#125; 1234567891011121314151617function App() &#123; const &#123; list, setList &#125; = useList(); return ( &lt;div className="App"&gt; &lt;h1&gt;List&lt;/h1&gt; &#123;list ? ( &lt;ol&gt; &#123;list.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt; ))&#125; &lt;/ol&gt; ) : ( "加载中..." )&#125; &lt;/div&gt; );&#125; 如上述代码，useList这个 api 就是自定义的。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react造轮子-Icon组件]]></title>
    <url>%2F2019%2F07%2F14%2Freact%E9%80%A0%E8%BD%AE%E5%AD%90-2%2F</url>
    <content type="text"><![CDATA[使用 React.FunctionComponent 与接收 props1234567891011import React from "react";interface IconProps &#123; name: string;&#125;const Icon: React.FunctionComponent&lt;IconProps&gt; = props =&gt; &#123; return &lt;span&gt;&#123;props.name&#125;&lt;/span&gt;;&#125;;export default Icon; 使用 function 定义一个组件时，需要使用React.FunctionComponent来指定组件的类型。如果要定义组件的props是符合哪个接口，就需要在React.FunctionComponent后面加&lt;&#39;已定义好的interface&#39;&gt;。这样定义后，在使用 Icon 组件时，name 属性传错是就会自动报错。 引入 svg 文件1import wechat from "./icon/wechat.svg"; 首先引入 svg 文件，这时候会报错，需要安装相应的 loader，并且 webpack 和 tsconfig 都需要做配置。 安装svg-sprite-loader，并且在webpack.config.js文件做出相应 loader 配置 在 types 目录下的custom.d.ts文件中添加配置声明 1234declare module '*.svg' &#123; const content: any; export default content;&#125; 在tsconfig.json文件内添加如下规则 1234"include": [ "lib/**/*", "types/**/*"], 在标签内使用 svg 文件123456789101112131415161718import "./icon/wechat.svg";import React from "react";interface IconProps &#123; name: string;&#125;const Icon: React.FunctionComponent&lt;IconProps&gt; = props =&gt; &#123; return ( &lt;span&gt; &lt;svg&gt; &lt;use xlinkHref="#wechat"&#125;&lt;/use&gt; &lt;/svg&gt; &lt;/span&gt; );&#125;;export default Icon; 让 Icon 组件响应所有事件123interface IconProps extends React.SVGAttributes&lt;SVGElement&gt; &#123; name: string;&#125; IconProps这个接口，不可能把所有事件都定义一遍，因为事件太多了，只需IconProps接口继承与React.SVGAttributes&lt;SVGElement&gt;就可以。]]></content>
      <categories>
        <category>TypeScript学习</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React造轮子-项目搭建]]></title>
    <url>%2F2019%2F07%2F06%2Freact%E9%80%A0%E8%BD%AE%E5%AD%90-1%2F</url>
    <content type="text"><![CDATA[创建目录与远程仓库在GitHub上新建一个远程仓库，创建时添加readme文件，然后使用git clone把远程仓库克隆到本地。 npm初始化进入到本地的项目目录，使用npm init -y命令，在本地新建一个package.json文件。 安装webpack使用yarn add webpack webpack-cli --dev命令，dev的意思就是安装到开发者的依赖里边，也就是在package.json文件中多了一个devDependenceies属性。 新建lib/index.tsx文件在项目目录下，新建一个lib目录，lib目录下新建一个index.tsx文件，在文件内先随意写一行log代码。 新建webpack.config.js在项目目录下新建一个webpack.config.js文件，然后配置webpack： 1234567891011121314151617181920const path = require('path')module.exports = &#123; mode: 'production', entry: &#123; index: './lib/index.tsx' &#125;, output: &#123; path: path.resolve(__dirname, 'dist/lib'), library: 'XinChen UI', libraryTarget: 'umd' &#125;, module: &#123; rules: [ &#123; test: /\.tsx?$/, loader: 'awesome-typescript-loader' &#125; ] &#125;&#125; 配置entry，这表示项目代码入口在哪里，目前先定为lib目录下的index.tsx文件； 配置output，这表示项目打包后所放置代码的位置，这里的libray表示项目最终的名称叫什么，librayTarget表示我们自己的库的格式是什么，； 配置mudules.rules，首先要处理.tsx文件，配置了awesome-typescript-loader这个loader，配置完后需要安装这个loader：yarn add awesome-typescript-loader --dev(安装所有的loader都是后面加--dev，因为loader只有开发者用到)； 安装typescript：yarn add typescript --dev，添加tsconfig.json和tslint.json文件; 配置mode，一般mode值为production或者development，第一次先设置为production； 安装webpack-dev-server与配置webpack.config.dev.js首先安装webpack-dev-server：yarn add webpack-dev-server --dev，这样就可以使用命令npx webpack-devserver来启动项目；安装html-webpack-plugin：yarn add html-webpack-plugin --dev，然后在webpack.config.js文件中添加下面代码： 12345678910const HtmlWebpackPlugin = require('html-webpack-plugin');modules.exports = &#123; // ... plugins: [ new HtmlWebpackPlugin(&#123; title: 'XinChen UI', template: 'index.html' &#125;) ]&#125; 这样使用命令npx webpack-dev-server，浏览器会启动localhost:8080域名，打开项目目录下的index.html文件，并且这个html文件会自动使用lib目录下的index.tsx文件作为js文件。接下来，在package.json文件内，scripts中添加如下两行代码： 12"start": "webpack-dev-server","build": "webpack" 这样我们启动项目是可以使用yarn start命令，打包项目可以使用yarn build命令。 使用React首先安装react和react-dom：yarn add react react-dom，安装完成后，如果直接使用React，会报一个错误提示： 12无法找到模块“react”的声明文件。“/Users/xinchen/Public/self_work/XinChen-UI/node_modules/react/index.js”隐式拥有 "any" 类型。Try `npm install @types/react` if it exists or add a new declaration (.d.ts) file containing `declare module 'react';`ts(7016) 错误提示很明显，没有安装@types/react，所以需要继续安装@types/react和@types/react-dom：yarn add @types/react @types/react-dom --dev。 在webpack.config.json文件内增加一个配置： 123456modules.exports = &#123; // ... resolve: &#123; extensions: ['.ts', '.tsx', '.js'. '.jsx'] &#125;&#125; 这样，当我们引入上述四种文件时才能正常引用。在yarn start的时候，会有一个警告，说index.js文件太大，这个需要在webpack.config.json文件中把mode值改为development，这样在开发模式下，不会管index.js是不是太大了。 1234567891011121314151617modules.exports = &#123; // ... enternals: &#123; react: &#123; commonjs: 'react', commonjs2: 'react', amd: 'react', root: 'React', &#125;, 'react-dom': &#123; commonjs: 'react-dom', commonjs2: 'react-dom', amd: 'react-dom', root: 'ReactDom', &#125; &#125;&#125; 再在webpack.config.json文件中加入上述代码，意思就是告诉webpack，enternals内的是外部的库，这样打包的index.js文件就不会包含react的代码。 配置webpack.config.dev.js和webpack.config,prod.js123456789101112131415161718192021222324// webpack.config.jsconst path = require('path');module.exports = &#123; entry: &#123; index: './lib/index.tsx' &#125;, output: &#123; path: path.resolve(__dirname, './dist/lib'), library: 'XinChen UI', libraryTarget: 'umd' &#125;, resolve: &#123; extensions: ['.ts', '.tsx', '.js', '.jsx'] &#125;, module: &#123; rules: [ &#123; test: /\.tsx?$/, loader: 'awesome-typescript-loader' &#125; ] &#125;&#125; 12345678910111213// webpack.config.dev.jsconst base = require('./webpack.config');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = Object.assign(&#123;&#125;, base, &#123; mode: 'development', plugins: [ new HtmlWebpackPlugin(&#123; title: 'XinChen UI', template: 'index.html' &#125;) ],&#125;) 1234567891011121314151617181920// webpack.config.prod.jsconst base = require('./webpack.config');module.exports = Object.assign(&#123;&#125;, base, &#123; mode: 'production', enternals: &#123; react: &#123; commonjs: 'react', commonjs2: 'react', amd: 'react', root: 'React', &#125;, 'react-dom': &#123; commonjs: 'react-dom', commonjs2: 'react-dom', amd: 'react-dom', root: 'ReactDom', &#125; &#125;&#125;) 三个webpack配置代码如上述所示，webpack.config.js文件是共有的配置，webpack.config.dev.js是开发环境配置，webpack.config.prod.js文件是生产环境配置。同时还需要修改package.json文件如下代码： 12345"scripts": &#123; //... "start": "webpack-dev-server --config webpack.config.dev.js", "build": "webpack --config webpack.config.prod.js"&#125;, 打包生产.d.ts文件在tsconfig.json文件这加入这么一行：&quot;outDir&quot;: &quot;dist&quot;，这样重新打包后，dist目录下就会有index.d.ts和Button.d.ts文件（其实Button.d.ts文件是不需要的），那如何去掉这个文件呢，在这里先挖个坑。 配置Jest单元测试 运行： 1yarn add --dev jest babel-jest @babel/preset-env @babel/preset-react react-test-renderer 在根目录下添加.babelrc文件，在文件内添加如下代码： 12345&#123; "presets": [ "react-app" ]&#125; 在package.json文件内的scripts中添加如下一行代码： 1"test": "cross-env NODE_ENV=test jest --config=jest.config.js --runInBand" 添加jest.config.js文件，在文件内添加如下代码： 12345678910111213141516171819202122module.exports = &#123; verbose: true, clearMocks: false, collectCoverage: false, reporters: ["default"], moduleFileExtensions: ['js', 'jsx', 'ts', 'tsx'], moduleDirectories: ['node_modules'], globals: &#123; 'ts-jest': &#123; tsConfig: 'tsconfig.test.json', &#125;, &#125;, moduleNameMapper: &#123; "\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$": "&lt;rootDir&gt;/test/__mocks__/file-mock.js", &#125;, testMatch: ['&lt;rootDir&gt;/**/__tests__/**/*.unit.(js|jsx|ts|tsx)'], transform: &#123; "^.+unit\\.(js|jsx)$": "babel-jest", '^.+\\.(ts|tsx)$': 'ts-jest', &#125;, setupFilesAfterEnv: ["&lt;rootDir&gt;test/setupTests.js"]&#125; 安装ts-jest：yarn add ts-jest --dev，并且创建test目录，并在这个目录下创建一个setupTests.js文件，目前这个文件暂时是空的。 安装@types/jest：yarn add @types/jest --dev; 在根目录下创建一个tsconfig.test.json文件，并在该文件下添加如下代码： 123&#123; "extends": "./tsconfig.json"&#125;]]></content>
      <categories>
        <category>TypeScript学习</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript+React入门]]></title>
    <url>%2F2019%2F06%2F29%2Ftypescript-learning6%2F</url>
    <content type="text"><![CDATA[项目构建12345npx create-react-app my-app --typescript// oryarn create react-app my-app --typescript 安装完成后，cd my-app，然后yarn start，这样项目就正式启动了。 工程目录结构不同点 入口文件还是index文件，不过由之前的index.jsx变成了index.tsx； 所有的组件之前是.jsx文件，现在都是.tsx文件； 简单写一个按钮组件12345678910111213// Button.tsximport React from 'react';import './Button.css'class Button extends React.Component &#123; render() &#123; return ( &lt;div className="btn"&gt;&#123;this.props.children&#125;&lt;/div&gt; ); &#125;&#125;export default Button; 12345678 /* Button.css */.btn&#123; display: inline-block; border: 1px solid black; border-radius: 4px; padding: 4px; cursor: pointer;&#125; 12345678910111213// App.tsximport React from 'react';import Button from './Button';const App: React.FC = () =&gt; &#123; return ( &lt;div className="App"&gt; &lt;Button&gt;Click&lt;/Button&gt; &lt;/div&gt; );&#125;export default App; 接收props如果此时在Button组件上传一个值：&lt;Button size=&quot;big&quot;&gt;Click&lt;/Button&gt;，此时还未编译就会报错，报错提示：不能将类型“{ children: string; size: string; }”分配给类型“IntrinsicAttributes…，其实意思就是Button组件没有定义接收size属性。为了解决这个报错，那就要在Button组件内定义size属性，有下面几种方式： class Button extends React.Component&lt;{size: string}&gt;...，直接在React.Component后面加一个泛型，只是这种方式在有多个属性时就会写得很乱，不推荐； type Props = {size: string;} class Button extends React.Component&lt;Props&gt;，用type关键字声明一个类型别名； interface Props = {size: string;} class Button extends React.Component&lt;Props&gt;，直接定义一个接口，普遍用这种方式； constructor构造函数传参12345678910111213141516171819import React from 'react';import './Button.css'interface IProps &#123; size: string;&#125;class Button extends React.Component&lt;IProps&gt; &#123; constructor(props) &#123; //报错，参数“props”隐式具有“any”类型。 super(props) &#125; render() &#123; return ( &lt;div className="btn"&gt;&#123;this.props.children&#125;&lt;/div&gt; ); &#125;&#125;export default Button; 上述代码，constructor构造器中直接传入props参数会报错， 必须定义props参数是上述定义的IProps接口类型constructor(props: IProps)。 定义state内部属性类型12345678910111213141516171819202122import React from 'react';import './Button.css'interface IProps &#123; size: string;&#125;class Button extends React.Component&lt;IProps&gt; &#123; constructor(props: IProps) &#123; super(props); this.state = &#123; n: 1 &#125; &#125; render() &#123; return ( &lt;div className="btn"&gt;&#123;this.props.children&#125;&#123;this.state.n&#125;&lt;/div&gt; ); // 报错，类型“Readonly&lt;&#123;&#125;&gt;”上不存在属性“n”。 &#125;&#125;export default Button; 上述代码这样直接写state，在下面代码使用时会报错，根据报错信息，其实意思就是没有定义n是什么类型，所以需要事先定义好n的类型，增加如下代码： 12345678910111213141516interface IState &#123; n: number;&#125;class Button extends React.Component&lt;IProps, IState&gt; &#123; constructor(props: IProps) &#123; super(props); this.state = &#123; n: 1 &#125; &#125; render() &#123; return ( &lt;div className="btn"&gt;&#123;this.props.children&#125;&#123;this.state.n&#125;&lt;/div&gt; ); &#125;&#125; 使用函数回调1234567891011121314// App.tsxclass App extends React.Component &#123; click(e: React.MouseEvent) &#123; console.log('click') console.log(e) &#125; render() &#123; return ( &lt;div className="App"&gt; &lt;Button size="big" onClick=&#123;this.click&#125;&gt;Click&lt;/Button&gt; &lt;/div&gt; ); &#125;&#125; 12345678910111213141516171819202122// Button.tsxinterface IProps &#123; size: string; onClick: React.MouseEventHandler;&#125;interface IState &#123; n: number;&#125;class Button extends React.Component&lt;IProps, IState&gt; &#123; constructor(props: IProps) &#123; super(props); this.state = &#123; n: 1 &#125; &#125; render() &#123; return ( &lt;div className="btn" onClick=&#123;this.props.onClick&#125;&gt;&#123;this.props.children&#125;&#123;this.state.n&#125;&lt;/div&gt; ); &#125;&#125; 如上述代码，Button组件中需要定义函数类型，由于是一个鼠标事件，定义为React.MouseEventHandler；在App文件中，在函数中使用e这个参数，也需要定义类型为React.MouseEvent。]]></content>
      <categories>
        <category>TypeScript学习</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>JavaScript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript+Vue入门]]></title>
    <url>%2F2019%2F06%2F26%2Ftypescript-learning5%2F</url>
    <content type="text"><![CDATA[工程创建 如果没有安装Vue cli，需要先安装：npm install --global @vue/cli; 创建一个新工程，如果已经在自己手动创建好的目录下：vue create .，如果没有手动创建目录：vue create my-project-name; 工程构建时，提示Check the features needed for your project时，选择了Babel、TypeScript、CSS Pre-processors; 提示Use class-style component syntax?时，选择yes； 工程目录部分结构不同点src目录下，有三个.ts文件main.ts shims-tsx.d.ts shims-vue.d.ts，main.ts依然是入口文件，shims-tsx.d.ts文件主要方便在ts中使用jsx语法，shims-tsx.d.ts文件用于ts识别.vue文件； 基础语法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;template&gt; &lt;div id="app"&gt; &lt;input v-model="msg"&gt; &lt;p&gt;prop: &#123;&#123;propMessage&#125;&#125;&lt;/p&gt; &lt;p&gt;msg: &#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;p&gt;helloMsg: &#123;&#123;helloMsg&#125;&#125;&lt;/p&gt; &lt;p&gt;computed msg: &#123;&#123;computedMsg&#125;&#125;&lt;/p&gt; &lt;button @click="greet"&gt;Greet&lt;/button&gt; &lt;HelloWorld msg="Welcome to Your Vue.js + TypeScript App"/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; Component, Vue &#125; from 'vue-property-decorator';import HelloWorld from './components/HelloWorld.vue';@Component(&#123; props: &#123; propMessage: String &#125;, components: &#123; HelloWorld, &#125;,&#125;)export default class App extends Vue &#123; // initial data msg = 123 // use prop values for initial data helloMsg = 'Hello, ' + this.propMessage // lifecycle hook mounted () &#123; this.greet() &#125; // computed get computedMsg () &#123; return 'computed ' + this.msg &#125; // method greet () &#123; alert('greeting: ' + this.msg) &#125;&#125;&lt;/script&gt; Component和Vue从vue-property-decorator引入； props和components都放在@Component里边声明； 初始数据直接使用msg = 123的形式； 方法、钩子函数等都放在类似上述代码App对象内；]]></content>
      <categories>
        <category>TypeScript学习</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>JavaScript</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript-泛型]]></title>
    <url>%2F2019%2F06%2F20%2Ftypescript-learning4%2F</url>
    <content type="text"><![CDATA[泛型泛型的使用123456function returnIt&lt;T&gt;(sth: T): T &#123; return sth;&#125;;let s = returnIt&lt;string&gt;('hi');let s2 = returnIt&lt;number&gt;('hello') // 报错了 泛型就是用一个东西表示广泛的类型，由如上述代码，在函数变量名returnIt后面加&lt;T&gt;，然后函数参数指定T类型，函数返回也是T类型，并且这个T可以写任意字母。returnIt&lt;number&gt;(&#39;hello&#39;)会报错，因为&#39;hello&#39;是string类型，但是函数调用时说明了接受number类型参数。 1234567891011function returnIt&lt;T&gt;(sth: T): T &#123; return sth;&#125;;interface Human &#123; name: string; age: number;&#125;let s = returnIt&lt;Human&gt;(&#123;name: 'jack', age: 18&#125;)let s1 = returnIt(&#123;name: 'jack', age: 18&#125;)let s2 = returnIt&lt;Human&gt;(&#123;name: 'jack'&#125;) // 报错 泛型和接口一起使用，由如上述代码，s s1都可以，s2会报错，因为传入函数的参数不符合接口的定义。 使用泛型变量123456function returnArray&lt;T&gt;(array: T[]): T[] &#123; return array;&#125;;let s = returnArray([1,2,3]);let s1 = returnArray('hi'); // 报错，因为'hi'不是一个数组 使用泛型类型，可以说明函数参数是一个广泛类型的数组（不关心这个数组内部是什么类型）。 泛型类12345678class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) &#123; return x + y; &#125;; 这个是官方文档的一个例子，当myGenericNumber实例化时，myGenericNumber内就有一个number类型的zeroValue属性，还有一个add方法，这个方法接收两个都是number类型的参数，返回值也是number类型。 泛型约束1234567891011121314151617// 1function returnIt&lt;T&gt;(sth: T): T &#123; console.log(sth.length); // 报错，sth没有length属性 return sth;&#125;;let s = returnIt&lt;string&gt;('hi');// 2interface hasLength &#123; length: number;&#125;function returnIt&lt;T extends hasLength&gt;(sth: T): T &#123; console.log(sth.length); return sth;&#125;;let s = returnIt&lt;string&gt;('hi'); 上述代码第一种情况下，泛型T并没有length属性，所以当访问length属性时，自然会报错，这就是对泛型的约束。第二种情况下，定义了一个具有length属性的接口，并且泛型T继承与接口hasLength，这样就不会报错了。]]></content>
      <categories>
        <category>TypeScript学习</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript-函数]]></title>
    <url>%2F2019%2F06%2F20%2Ftypescript-learning3%2F</url>
    <content type="text"><![CDATA[函数函数其实也是对象，只是是一个特殊的对象，是可以被调用（call）的对象。 函数类型1234567function add(x: number, y: number): number &#123; return x + y;&#125;ley add2 = function(x: number, y: number): number &#123; return x + y;&#125; 给每个参数添加类型之后再为函数本身添加返回值的类型，ts可以根据返回语句自动推断出返回值类型，如果实际返回值不是规定的类型就会报错。 123let add2: (x: number, y: number) =&gt; number = function(x: number, y: number): number &#123; return x + y;&#125; 上述代码是表示完整函数类型，其实有两部分，等于号前面和后面两部分；等于号前面部分，意思就是给add2函数定义了一个函数类型，是一个接收两个number类型的参数并且返回值是number类型的函数类型；等于号后面就是一个匿名函数，这个函数也是符合前面定义的函数类型的函数。上述代码中，let add2: (x: number, y: number) =&gt; number其实是这样的：let add2: ((x: number, y: number) =&gt; number) 123let add2: (x: number, y: number) =&gt; number = function(x, y): &#123; return x + y;&#125; 如果在赋值语句的一边指定了类型，但是另一边没有类型的话，ta编译器会自动识别出类型。 可选参数和默认参数12345678910function buildName(firstName: string, lastName?: string) &#123; if (lastName) &#123; return firstName + " " + lastName; &#125; else &#123; return firstName; &#125;&#125;let res1 = buildName('Bob');let res2 = buildName('Bob', 'Adams'); 对于可选参数，可以在参数后面加一个问号，如上述代码lastName?: string。 1234567function buildName(firstName: string, lastName='Smith') &#123; return firstName + " " + lastName;&#125;let res1 = buildName('Bob'); // Bob Smithlet res2 = buildName('Bob', 'Adams'); // Bob Adamslet res3 = buildName('Bob', undefined) // Bob Smith 在ts里，可以为参数提供一个默认值（当用户没有传值或者传了undefined）。 剩余参数12345function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + ' ' + restOfName.jion(' ')&#125;let fullName = buildName("Joseph", "Samuel", "Lucas", "MacKinzie"); 剩余参数会被当做个数不限的可选参数，可以一个都没有，同样也可以有任意个；在参数前加...，表示一个数组，冒号后面可以定义是个string类型数组还是number类型数组或其他类型数组；在函数体内可以使用这个数组。 this和箭头函数this的值在函数被调用的时候才确定，也就是说，this值其实是这个函数的参数，只有调用这个函数时才知道this的值是什么；在TS里，this本质还是和JS里的this一样，不过在TS里，可以事先给this指定类型，或指定必须符合哪个接口或是哪个类： 12345678910interface Human &#123; name: string; age: number;&#125;function fn(this: Human) &#123; console.log(this);&#125;fn.call(&#123;name: 'jack', age: 18&#125;); // passfn(); // error 函数的重载123456789function add(n1: number, n2: number);function add(n1: string, n2: string);function add(n1, n2) &#123; return n1 + n2;&#125;add(1, 2); // pass =&gt; 3add('a', 'b') // pass =&gt; 'ab'add(1, '2') // error 两个参数不符合同时是string类型或者number类型 上述代码中，第一行和第二行表示对函数参数类型的定义，可以同时是number``，或者同时是string`，第三行开始的函数就是表示函数功能的具体实现。 拓展类型推断123456function add(n1: string, n2: string) &#123; return n1 + n2;&#125;let s = add('a' + 'b');console.log(s.split('')); // pass add函数在声明时并不需要声明返回值时什么类型，因为TS自己会推断函数的返回值是什么类型，所以当s.split(&#39;&#39;)时不会报错。 类型兼容123456789interface Human &#123; name: string; age: number;&#125;let human1: Human = &#123;name: 'jack', age: 18, gender: 'male'&#125;; //报错，因为对象不符合接口Human的定义，多了gender属性let x = &#123;name: 'jack', age: 18, gender: 'male'&#125;;let human2: Human = x; //这里不会报错，pass 至于这样设计的目的，应该是可以让我们少些一些代码，节约类型的个数。 Unsound12345678910111213141516171819enum EventType &#123; Mouse, Keyboard &#125;interface Event &#123; timestamp: number; &#125;interface MouseEvent extends Event &#123; x: number; y: number &#125;interface KeyEvent extends Event &#123; keyCode: number &#125;function listenEvent(eventType: EventType, handler: (n: Event) =&gt; void) &#123; /* ... */&#125;// Unsound, but useful and commonlistenEvent(EventType.Mouse, (e: MouseEvent) =&gt; console.log(e.x + ',' + e.y));// Undesirable alternatives in presence of soundnesslistenEvent(EventType.Mouse, (e: Event) =&gt; console.log((&lt;MouseEvent&gt;e).x + ',' + (&lt;MouseEvent&gt;e).y));listenEvent(EventType.Mouse, &lt;(e: Event) =&gt; void&gt;((e: MouseEvent) =&gt; console.log(e.x + ',' + e.y)));// Still disallowed (clear error). Type safety enforced for wholly incompatible typeslistenEvent(EventType.Mouse, (e: number) =&gt; console.log(e)); // 报错]]></content>
      <categories>
        <category>TypeScript学习</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript-类]]></title>
    <url>%2F2019%2F06%2F19%2Ftypescript-learning2%2F</url>
    <content type="text"><![CDATA[类类的声明12345678910111213class Human &#123; name: string; age: number; constructor(name: string, age: number) &#123; this.name = name; this.age = age; &#125;; move() &#123; console.log('可以行走...') &#125;;&#125;let jack = new Human('jack', 18) // jack ==&gt; &#123;'jack', 18&#125; 类的声明用class修饰符，内部可以使用构造器constructor，构造器constructor是一个函数，可以让我们用new ...来实例化一个对象，并且constructor的参数可以设置默认值；Human类内部可以定义方法，类似上述move函数。 类的静态属性1234567891011class Human &#123; static a = 1; name: string; age: number; constructor(name: string, age: number) &#123; this.name = name; this.age = age; &#125;;&#125;let jack = new Human('jack', 18) 类的静态属性用static修饰符，每个实例想要访问这个属性的时候，都要类似于jack.a来访问。 类的私有属性12345678910111213class Human &#123; name: string; age: number; private secret: string; constructor(name: string, age: number) &#123; this.name = name; this.age = age; this.secret = '这是我的秘密'; &#125;;&#125;let jack = new Human('jack', 18)console.log(jack.secret) // ==&gt; 报错 类的私有属性使用private修饰符，jack访问secret属性时会报错，secret属性只能在Human类种使用。这里增加一点说明，name和age属性默认是public，其实是这样：public name: string; public age: number;。 readonly修饰符1234567891011class Human &#123; name: string; readonly age: number; constructor(name: string, age: number) &#123; this.name = name; this.age = age; &#125;;&#125;let jack = new Human('jack', 18)jack.age = 8 // 报错，age是只读的 用readonly关键字将属性设置为只读，只读属性必须在声明时或这早函数里被初始化。 类的继承1234567891011121314151617181920class Animal &#123; type: string; constructor(type: string) &#123; this.type = type; &#125;; move(): void &#123; // ... &#125;;&#125;class Human extends Animal &#123; name: string; age: number; constructor(name: string, age: number) &#123; super('哺乳动物'); this.name = name; this.age = age; &#125;;&#125;let jack = new Human('jack', 18) // jack ==&gt; &#123;'jack', 18&#125; 类的继承也是用修饰符extends来实现，并且，Human继承Animal，在Human的constructor内需要调用super()；上述代码中，super(&#39;哺乳动物&#39;)相当于调用了Animal种的constructor()，这样jack就有了type属性，并且jack.type === &#39;哺乳动物&#39;。 理解protected1234567891011121314151617181920212223class Animal &#123; type: string; protected hand: boolean; constructor(type: string, hand: boolean) &#123; this.type = type; this.hand = hand &#125;; move(): void &#123; // ... &#125;;&#125;class Human extends Animal &#123; name: string; age: number; constructor(name: string, age: number) &#123; super('哺乳动物', true); this.name = name; this.age = age; &#125;;&#125;let jack = new Human('jack', 18)console.log(jack.hand) // ==&gt; 报错 protected修饰符雨private类似，但有一点不同，protected成员在它的子类仍然可以使用，而private就不可以。 抽象类抽象类也可以叫做“爸爸类”：专门当作别的类的爸爸的类；也可以叫做“没有写完的类”：只描述有什么方法，并没有完全实现这些方法。 12345678910111213141516171819202122abstract class Animal &#123; abstract makeNoice(): void &#123;&#125;; move(): void &#123; // ... &#125;;&#125;let animal = new Animal() // 报错，因为Animal是抽象类，makeNoice方法并没有写完class Human extends Animal &#123; name: string; age: number; constructor(name: string, age: number) &#123; super(); this.name = name; this.age = age; &#125;; makeNoice(): void &#123; console.log('说普通话'); &#125;&#125;let jack = new Human('jack', 18) 抽象类要在声明时前面加abstract修饰符； 抽象类内部有一个方法，这个方法并不能在当时写全，那这个方法前面加一个abstract修饰符； 由如上述代码中，new Animal()实例化会报错，因为内部有方法并没有写全； 父类中如果有未写完的方法，那子类（非抽象类）中需要写完它；]]></content>
      <categories>
        <category>TypeScript学习</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript基础]]></title>
    <url>%2F2019%2F06%2F14%2Ftypescript-learning1%2F</url>
    <content type="text"><![CDATA[变量数据类型 JS七种数据类型（number、string、undefined、null、object、boolean、symbol） any1234let n1:number = 1n1 = '1' // errorlet n2:any = 2n2 = '2' // pass 如果一个变量在赋值时声明了是number，后面如果把不是number的数据赋值给n1，那就会报错；如果一个变量在赋值时声明的时any，后面可以把任何类型的数据赋值给n2 枚举(enum)1234567891011enum Gender &#123; Man, Woman &#125;let jack:Gender = Gender.Manconsole.log(jack) // =&gt; 0jack = Gender.Womanconsole.log(jack) // =&gt; 1enum Gender1 = &#123; Man='man', Woman='woman' &#125;let jack:Gender1 = Gender1.Manconsole.log(jack) // =&gt; 'man'jack = Gender1.Womanconsole.log(jack) // =&gt; 'woman' 枚举用关键字enum来声明，默认情况下，元素编号从0开始，所以第一种情况的jack值默认是0。也可以手动指定成员的数据，就类似上述第二种情况。如果在给jack赋值时，不小心赋值了类似于Gender.Men，这样就会报错； void代表空类型，一般用在没有返回值的函数声明时，类似于下述情况： 123function a(b: any): void &#123; console.log(a)&#125; never 小tips：默认情况下，null或undefined是所有类型的子类型，就是说可以把null或undefined赋值给number、string等类型的变量。 类型断言12345let str1: any = '123'console.log( (&lt;string&gt;str1).split('') ) // =&gt; passlet str2: any = '123'console.log( (str2 as string).split('') ) // =&gt; pass 有两种形式：1.&lt;string&gt;str 2.str2 as string通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。TypeScript会假设你，程序员，已经进行了必须的检查。 接口接口基础接口就是用代码描述一个对象必须有什么属性或者方法，但是有没有其他属性或方法就不管。 123456interface Human &#123; name: string; age: number;&#125;let jack: Human = &#123;name: 'jack', age: 18&#125; 接口用关键字interface来声明，例如上述代码，如果jack对象声明时少了name或者age属性，就会报错。 12345678910111213141516171819202122interface Head &#123; eye: number; nose: number;&#125;interface Human &#123; readonly name: string; age: number; head: Head; likedGame?: Array&lt;string&gt;; say(word: string) : void;&#125;let jsck: Human = &#123; name: 'jack', age: 18, head: &#123;eye: 2, nose: 1&#125;, say(word: string) &#123; console.log(word) &#125;&#125;jack.name = 'gavin' // =&gt; error 如果一个接口内定义了必须还有对象，就类似上述再声明另一个接口； 如果一个接口内定义了必须有一个方法，就类似上述在接口内部直接定一个方法； 以上述代码为例，在接口定义时，在某一个属性前加一个readonly关键字，后面如果对jsck的name属性做修改就会报错； 如果定义一个接口时，在某个属性后面加一个？，表述对象声明时可以不声明这个对象，类似上述代码种的likedGame； 接口描述函数1234567interface SearchFunc &#123; (a: string, b: string): boolean;&#125;let searchF = function (c: string, d: string): boolean &#123; // ...&#125; 由如上述代码定义一个描述函数的接口，注意：上述a、b并不与c、d有什么关系。 如果接口描述的函数，这个函数内也有一个属性也是函数？代码如下： 12345678910111213141516interface 二则运算 &#123; (a: number, b: number): number; 逆运算(a: number, b: number): number;&#125;let fn = ((): 二则运算 =&gt; &#123; let x: any = function(a: number, b: number): number &#123; return a + b; &#125;; x.逆运算 = function(a: number, b: number): number &#123; return a - b; &#125;; return x;&#125;)()let add: 二则运算 = fn(); 接口的继承12345678910111213141516// 1interface Animal &#123; move(): void;&#125;interface Human extends Animal &#123; name: string; age: number;&#125;let jack: Human = &#123; name: 'jack', age: 18, move() &#123; // ... &#125;&#125; 接口的继承用关键字extends来实现，上述代码中，如果声明jack时没有声明move方法就会报错。 1234567891011121314151617181920// 2interface Animal &#123; move(): void;&#125;interface Human &#123; name: string; age: number;&#125;interface Gen extends Human, Animal &#123; gender: string&#125;let jack: Gen = &#123; name: 'jack', age: 18, gender: 'man'; move() &#123; // ... &#125;&#125; 一个接口可以继承多个接口，由如上述代码Gen extends Human, Animal，继承的多个接口用逗号隔开；当然上述代码中，声明Human接口时也可以继承Animal=&gt;Human extends Animal。]]></content>
      <categories>
        <category>TypeScript学习</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
