<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[typescript-泛型]]></title>
    <url>%2F2019%2F06%2F20%2Ftypescript-learning4%2F</url>
    <content type="text"><![CDATA[泛型泛型的使用123456function returnIt&lt;T&gt;(sth: T): T &#123; return sth;&#125;;let s = returnIt&lt;string&gt;('hi');let s2 = returnIt&lt;number&gt;('hello') // 报错了 泛型就是用一个东西表示广泛的类型，由如上述代码，在函数变量名returnIt后面加&lt;T&gt;，然后函数参数指定T类型，函数返回也是T类型，并且这个T可以写任意字母。returnIt&lt;number&gt;(&#39;hello&#39;)会报错，因为&#39;hello&#39;是string类型，但是函数调用时说明了接受number类型参数。 1234567891011function returnIt&lt;T&gt;(sth: T): T &#123; return sth;&#125;;interface Human &#123; name: string; age: number;&#125;let s = returnIt&lt;Human&gt;(&#123;name: 'jack', age: 18&#125;)let s1 = returnIt(&#123;name: 'jack', age: 18&#125;)let s2 = returnIt&lt;Human&gt;(&#123;name: 'jack'&#125;) // 报错 泛型和接口一起使用，由如上述代码，s s1都可以，s2会报错，因为传入函数的参数不符合接口的定义。 使用泛型变量123456function returnArray&lt;T&gt;(array: T[]): T[] &#123; return array;&#125;;let s = returnArray([1,2,3]);let s1 = returnArray('hi'); // 报错，因为'hi'不是一个数组 使用泛型类型，可以说明函数参数是一个广泛类型的数组（不关心这个数组内部是什么类型）。 泛型类12345678class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) &#123; return x + y; &#125;; 这个是官方文档的一个例子，当myGenericNumber实例化时，myGenericNumber内就有一个number类型的zeroValue属性，还有一个add方法，这个方法接收两个都是number类型的参数，返回值也是number类型。 泛型约束1234567891011121314151617// 1function returnIt&lt;T&gt;(sth: T): T &#123; console.log(sth.length); // 报错，sth没有length属性 return sth;&#125;;let s = returnIt&lt;string&gt;('hi');// 2interface hasLength &#123; length: number;&#125;function returnIt&lt;T extends hasLength&gt;(sth: T): T &#123; console.log(sth.length); return sth;&#125;;let s = returnIt&lt;string&gt;('hi'); 上述代码第一种情况下，泛型T并没有length属性，所以当访问length属性时，自然会报错，这就是对泛型的约束。第二种情况下，定义了一个具有length属性的接口，并且泛型T继承与接口hasLength，这样就不会报错了。]]></content>
      <categories>
        <category>TypeScript学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript-函数]]></title>
    <url>%2F2019%2F06%2F20%2Ftypescript-learning3%2F</url>
    <content type="text"><![CDATA[函数函数其实也是对象，只是是一个特殊的对象，是可以被调用（call）的对象。 函数类型1234567function add(x: number, y: number): number &#123; return x + y;&#125;ley add2 = function(x: number, y: number): number &#123; return x + y;&#125; 给每个参数添加类型之后再为函数本身添加返回值的类型，ts可以根据返回语句自动推断出返回值类型，如果实际返回值不是规定的类型就会报错。 123let add2: (x: number, y: number) =&gt; number = function(x: number, y: number): number &#123; return x + y;&#125; 上述代码是表示完整函数类型，其实有两部分，等于号前面和后面两部分；等于号前面部分，意思就是给add2函数定义了一个函数类型，是一个接收两个number类型的参数并且返回值是number类型的函数类型；等于号后面就是一个匿名函数，这个函数也是符合前面定义的函数类型的函数。上述代码中，let add2: (x: number, y: number) =&gt; number其实是这样的：let add2: ((x: number, y: number) =&gt; number) 123let add2: (x: number, y: number) =&gt; number = function(x, y): &#123; return x + y;&#125; 如果在赋值语句的一边指定了类型，但是另一边没有类型的话，ta编译器会自动识别出类型。 可选参数和默认参数12345678910function buildName(firstName: string, lastName?: string) &#123; if (lastName) &#123; return firstName + " " + lastName; &#125; else &#123; return firstName; &#125;&#125;let res1 = buildName('Bob');let res2 = buildName('Bob', 'Adams'); 对于可选参数，可以在参数后面加一个问号，如上述代码lastName?: string。 1234567function buildName(firstName: string, lastName='Smith') &#123; return firstName + " " + lastName;&#125;let res1 = buildName('Bob'); // Bob Smithlet res2 = buildName('Bob', 'Adams'); // Bob Adamslet res3 = buildName('Bob', undefined) // Bob Smith 在ts里，可以为参数提供一个默认值（当用户没有传值或者传了undefined）。 剩余参数12345function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + ' ' + restOfName.jion(' ')&#125;let fullName = buildName("Joseph", "Samuel", "Lucas", "MacKinzie"); 剩余参数会被当做个数不限的可选参数，可以一个都没有，同样也可以有任意个；在参数前加...，表示一个数组，冒号后面可以定义是个string类型数组还是number类型数组或其他类型数组；在函数体内可以使用这个数组。 this和箭头函数this的值在函数被调用的时候才确定，也就是说，this值其实是这个函数的参数，只有调用这个函数时才知道this的值是什么；在TS里，this本质还是和JS里的this一样，不过在TS里，可以事先给this指定类型，或指定必须符合哪个接口或是哪个类： 12345678910interface Human &#123; name: string; age: number;&#125;function fn(this: Human) &#123; console.log(this);&#125;fn.call(&#123;name: 'jack', age: 18&#125;); // passfn(); // error 函数的重载123456789function add(n1: number, n2: number);function add(n1: string, n2: string);function add(n1, n2) &#123; return n1 + n2;&#125;add(1, 2); // pass =&gt; 3add('a', 'b') // pass =&gt; 'ab'add(1, '2') // error 两个参数不符合同时是string类型或者number类型 上述代码中，第一行和第二行表示对函数参数类型的定义，可以同时是number``，或者同时是string`，第三行开始的函数就是表示函数功能的具体实现。 拓展类型推断123456function add(n1: string, n2: string) &#123; return n1 + n2;&#125;let s = add('a' + 'b');console.log(s.split('')); // pass add函数在声明时并不需要声明返回值时什么类型，因为TS自己会推断函数的返回值是什么类型，所以当s.split(&#39;&#39;)时不会报错。 类型兼容123456789interface Human &#123; name: string; age: number;&#125;let human1: Human = &#123;name: 'jack', age: 18, gender: 'male'&#125;; //报错，因为对象不符合接口Human的定义，多了gender属性let x = &#123;name: 'jack', age: 18, gender: 'male'&#125;;let human2: Human = x; //这里不会报错，pass 至于这样设计的目的，应该是可以让我们少些一些代码。]]></content>
      <categories>
        <category>TypeScript学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript-类]]></title>
    <url>%2F2019%2F06%2F19%2Ftypescript-learning2%2F</url>
    <content type="text"><![CDATA[类类的声明12345678910111213class Human &#123; name: string; age: number; constructor(name: string, age: number) &#123; this.name = name; this.age = age; &#125;; move() &#123; console.log('可以行走...') &#125;;&#125;let jack = new Human('jack', 18) // jack ==&gt; &#123;'jack', 18&#125; 类的声明用class修饰符，内部可以使用构造器constructor，构造器constructor是一个函数，可以让我们用new ...来实例化一个对象，并且constructor的参数可以设置默认值；Human类内部可以定义方法，类似上述move函数。 类的静态属性1234567891011class Human &#123; static a = 1; name: string; age: number; constructor(name: string, age: number) &#123; this.name = name; this.age = age; &#125;;&#125;let jack = new Human('jack', 18) 类的静态属性用static修饰符，每个实例想要访问这个属性的时候，都要类似于jack.a来访问。 类的私有属性12345678910111213class Human &#123; name: string; age: number; private secret: string; constructor(name: string, age: number) &#123; this.name = name; this.age = age; this.secret = '这是我的秘密'; &#125;;&#125;let jack = new Human('jack', 18)console.log(jack.secret) // ==&gt; 报错 类的私有属性使用private修饰符，jack访问secret属性时会报错，secret属性只能在Human类种使用。这里增加一点说明，name和age属性默认是public，其实是这样：public name: string; public age: number;。 readonly修饰符1234567891011class Human &#123; name: string; readonly age: number; constructor(name: string, age: number) &#123; this.name = name; this.age = age; &#125;;&#125;let jack = new Human('jack', 18)jack.age = 8 // 报错，age是只读的 用readonly关键字将属性设置为只读，只读属性必须在声明时或这早函数里被初始化。 类的继承1234567891011121314151617181920class Animal &#123; type: string; constructor(type: string) &#123; this.type = type; &#125;; move(): void &#123; // ... &#125;;&#125;class Human extends Animal &#123; name: string; age: number; constructor(name: string, age: number) &#123; super('哺乳动物'); this.name = name; this.age = age; &#125;;&#125;let jack = new Human('jack', 18) // jack ==&gt; &#123;'jack', 18&#125; 类的继承也是用修饰符extends来实现，并且，Human继承Animal，在Human的constructor内需要调用super()；上述代码中，super(&#39;哺乳动物&#39;)相当于调用了Animal种的constructor()，这样jack就有了type属性，并且jack.type === &#39;哺乳动物&#39;。 理解protected1234567891011121314151617181920212223class Animal &#123; type: string; protected hand: boolean; constructor(type: string, hand: boolean) &#123; this.type = type; this.hand = hand &#125;; move(): void &#123; // ... &#125;;&#125;class Human extends Animal &#123; name: string; age: number; constructor(name: string, age: number) &#123; super('哺乳动物', true); this.name = name; this.age = age; &#125;;&#125;let jack = new Human('jack', 18)console.log(jack.hand) // ==&gt; 报错 protected修饰符雨private类似，但有一点不同，protected成员在它的子类仍然可以使用，而private就不可以。 抽象类抽象类也可以叫做“爸爸类”：专门当作别的类的爸爸的类；也可以叫做“没有写完的类”：只描述有什么方法，并没有完全实现这些方法。 12345678910111213141516171819202122abstract class Animal &#123; abstract makeNoice(): void &#123;&#125;; move(): void &#123; // ... &#125;;&#125;let animal = new Animal() // 报错，因为Animal是抽象类，makeNoice方法并没有写完class Human extends Animal &#123; name: string; age: number; constructor(name: string, age: number) &#123; super(); this.name = name; this.age = age; &#125;; makeNoice(): void &#123; console.log('说普通话'); &#125;&#125;let jack = new Human('jack', 18) 抽象类要在声明时前面加abstract修饰符； 抽象类内部有一个方法，这个方法并不能在当时写全，那这个方法前面加一个abstract修饰符； 由如上述代码中，new Animal()实例化会报错，因为内部有方法并没有写全； 父类中如果有未写完的方法，那子类（非抽象类）中需要写完它；]]></content>
      <categories>
        <category>TypeScript学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript基础]]></title>
    <url>%2F2019%2F06%2F14%2Ftypescript-learning1%2F</url>
    <content type="text"><![CDATA[变量数据类型 JS七种数据类型（number、string、undefined、null、object、boolean、symbol） any1234let n1:number = 1n1 = '1' // errorlet n2:any = 2n2 = '2' // pass 如果一个变量在赋值时声明了是number，后面如果把不是number的数据赋值给n1，那就会报错；如果一个变量在赋值时声明的时any，后面可以把任何类型的数据赋值给n2 枚举(enum)1234567891011enum Gender &#123; Man, Woman &#125;let jack:Gender = Gender.Manconsole.log(jack) // =&gt; 0jack = Gender.Womanconsole.log(jack) // =&gt; 1enum Gender1 = &#123; Man='man', Woman='woman' &#125;let jack:Gender1 = Gender1.Manconsole.log(jack) // =&gt; 'man'jack = Gender1.Womanconsole.log(jack) // =&gt; 'woman' 枚举用关键字enum来声明，默认情况下，元素编号从0开始，所以第一种情况的jack值默认是0。也可以手动指定成员的数据，就类似上述第二种情况。如果在给jack赋值时，不小心赋值了类似于Gender.Men，这样就会报错； void代表空类型，一般用在没有返回值的函数声明时，类似于下述情况： 123function a(b: any): void &#123; console.log(a)&#125; never 小tips：默认情况下，null或undefined是所有类型的子类型，就是说可以把null或undefined赋值给number、string等类型的变量。 类型断言12345let str1: any = '123'console.log( (&lt;string&gt;str1).split('') ) // =&gt; passlet str2: any = '123'console.log( (str2 as string).split('') ) // =&gt; pass 有两种形式：1.&lt;string&gt;str 2.str2 as string通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。TypeScript会假设你，程序员，已经进行了必须的检查。 接口接口基础接口就是用代码描述一个对象必须有什么属性或者方法，但是有没有其他属性或方法就不管。 123456interface Human &#123; name: string; age: number;&#125;let jack: Human = &#123;name: 'jack', age: 18&#125; 接口用关键字interface来声明，例如上述代码，如果jack对象声明时少了name或者age属性，就会报错。 12345678910111213141516171819202122interface Head &#123; eye: number; nose: number;&#125;interface Human &#123; readonly name: string; age: number; head: Head; likedGame?: Array&lt;string&gt;; say(word: string) : void;&#125;let jsck: Human = &#123; name: 'jack', age: 18, head: &#123;eye: 2, nose: 1&#125;, say(word: string) &#123; console.log(word) &#125;&#125;jack.name = 'gavin' // =&gt; error 如果一个接口内定义了必须还有对象，就类似上述再声明另一个接口； 如果一个接口内定义了必须有一个方法，就类似上述在接口内部直接定一个方法； 以上述代码为例，在接口定义时，在某一个属性前加一个readonly关键字，后面如果对jsck的name属性做修改就会报错； 如果定义一个接口时，在某个属性后面加一个？，表述对象声明时可以不声明这个对象，类似上述代码种的likedGame； 接口描述函数1234567interface SearchFunc &#123; (a: string, b: string): boolean;&#125;let searchF = function (c: string, d: string): boolean &#123; // ...&#125; 由如上述代码定义一个描述函数的接口，注意：上述a、b并不与c、d有什么关系。 如果接口描述的函数，这个函数内也有一个属性也是函数？代码如下： 12345678910111213141516interface 二则运算 &#123; (a: number, b: number): number; 逆运算(a: number, b: number): number;&#125;let fn = ((): 二则运算 =&gt; &#123; let x: any = function(a: number, b: number): number &#123; return a + b; &#125;; x.逆运算 = function(a: number, b: number): number &#123; return a - b; &#125;; return x;&#125;)()let add: 二则运算 = fn(); 接口的继承12345678910111213141516// 1interface Animal &#123; move(): void;&#125;interface Human extends Animal &#123; name: string; age: number;&#125;let jack: Human = &#123; name: 'jack', age: 18, move() &#123; // ... &#125;&#125; 接口的继承用关键字extends来实现，上述代码中，如果声明jack时没有声明move方法就会报错。 1234567891011121314151617181920// 2interface Animal &#123; move(): void;&#125;interface Human &#123; name: string; age: number;&#125;interface Gen extends Human, Animal &#123; gender: string&#125;let jack: Gen = &#123; name: 'jack', age: 18, gender: 'man'; move() &#123; // ... &#125;&#125; 一个接口可以继承多个接口，由如上述代码Gen extends Human, Animal，继承的多个接口用逗号隔开；当然上述代码中，声明Human接口时也可以继承Animal=&gt;Human extends Animal。]]></content>
      <categories>
        <category>TypeScript学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
</search>
